# link

- [ë¦¬ëˆ…ìŠ¤ ì»¤ë„ì„ ë§Œë“¤ê¸° ìœ„í•´ ë§ˆìŠ¤í„° í•´ì•¼ 3ê¶Œì˜ ì±… How to do Linux Kernel dev.](#howto-do-linux-kernel-development)

- [A PROGRAM is not a PROCESS. | Core Dumped](https://youtu.be/7ge7u5VUSbE)

- Rustë¡œ ì»´íŒŒì¼ëŸ¬ ë§Œë“¤ê¸° ì‹œë¦¬ì¦ˆ
  - [Sketching It Out - Rust Clipper Compiler (EP.1) | CoderSauce](https://youtu.be/K7UGL1HyFJQ?si=brGkCDa2TpDMbIfP)
  - [240916_Bridging the Gap to Assembly - Rust Clipper Compiler (EP.2)CoderSauce](https://youtu.be/9_fDhaKUMbU?si=5jPdTgeivkvHPx10)
  - [Handcrafting Some Assembly in Rust - Clipper Compiler (EP.3)](https://youtu.be/4xSNH3Ql2Jk?si=la2IV_kw_qn-mkG-)
  - [Teaching my Compiler to Talk to Others - Rust Clipper Compiler (EP.4)](https://youtu.be/-rxm58qu7Rc)
  - [Expanding The Tree - Rust Clipper Compiler (EP.5) | CoderSauce](https://youtu.be/mS51V_L9Jz8?si=gzCTvgzpNfK6Oi_P)

- ìœ ë£Œ ë§í¬(ë¦¬ëˆ…ìŠ¤ ì»¤ë„ ë‚œì¤‘ì— ê²°ì œí•´ì„œ ë³´ì ë„˜ ì¢‹ë‹¤.)
  - [ë¦¬ëˆ…ìŠ¤ ì»¤ë„ ë‚œì¤‘ì— ê²°ì œí•´ì„œ ë³´ì ë„˜ ì¢‹ë‹¤.](#ìœ ë£Œ-ì½˜í…ì¸ ë‚œì¤‘ì—-ê²°ì œí•´ì„œ-ë³´ì)

- [ì™¸ë¶€ë§í¬) PopOSëŸ¬ìŠ¤íŠ¸ iced(GUI)(Alpha release of PopOS's Cosmic desktop environment, written in Rust and based on Iced )](https://www.reddit.com/r/rust/comments/1f38xni/alpha_release_of_poposs_cosmic_desktop/?rdt=55213)

- ìœ íŠœë¸Œ ì˜ìƒ ëª¨ìŒ
  - Arm
    - [240205 ìœ ë£Œê°•ì˜ì†Œê°œ (ì¸í”„ëŸ°-ë¡œë“œë§µ |'Arm ì•„í‚¤í…ì²˜ì˜ êµ¬ì¡°ì™€ ì›ë¦¬ ì €ì ì§ê°• ê°•ì˜'- ëª¨ë‘ ì—…ë¡œë“œ ì™„ë£Œ! | Austin Kim](https://m.youtube.com/watch?si=DAzymb8g8F7JhQC0&v=9kOdb7w_PCU&feature=youtu.be)
  - [ë¦¬ëˆ…ìŠ¤ ì»¤ë„ì˜ ì¡´ì¬ ì´ìœ _ê°„ë‹¨íˆ ì„¤ëª… êµ¿](https://youtube.com/shorts/ivyPFMZg4KI?si=4Qwqgt42CYHmC10s)
  - [(240806) Operating Systems Course for Beginners | freeCodeCamp.org](https://youtu.be/yK1uBHPdp30?si=aGUK8RRxTdXu1A-9)
  - [(210108) System Design Course for beginners | Geek's Lesson](https://youtu.be/MbjObHmDbZo?si=SwE1oWai_aaJZaN5)
  - [(250325) System Design was HARD until I Learned these 30 Concepts | Ashish Pratap Singh](https://youtu.be/s9Qh9fWeOAk?si=uNOk8J2o7eFDMAO8)
  - RISC-V ì•„í‚¤í…ì²˜
    - [RISC-Vì˜ìƒ ëª¨ì•„ë³´ê¸° | Austin Kim](https://youtube.com/playlist?list=PLRrUisvYoUw_4ES8R-H7lgjsqjZeKhI9W&si=nf6j59Z1IBzUai2d)
  - ë¦¬ëˆ…ìŠ¤ ì»¤ë„ì˜ êµ¬ì¡°ì™€ ì›ë¦¬
    - Armv8-A
      - [ì˜ìƒëª¨ì•„ ë³´ê¸°) ë¦¬ëˆ…ìŠ¤ ì»¤ë„ì˜ êµ¬ì¡°ì™€ ì›ë¦¬ 1ë¶€(v6.1, Armv8-A ê¸°ë°˜) | Austin Kim](https://youtube.com/playlist?list=PLRrUisvYoUw_bFoK0ahLy9MHfBgBZJyz4&si=WmveEC7wLZ9ZK0nP)
  - dr Jonas Birchì‹œë¦¬ì¦ˆ
    - [ì™¸ë¶€ì˜ìƒ (251003)Project: Coding a GRUB bootloader for booting Linux | dr Jonas Birch](https://www.youtube.com/watch?v=ukIajayMv5U&t=153s)


- ìš©ì–´ì •ë¦¬
  - [DPLê°œë…ì´í•´](#dplê°œë…ì´í•´)
  - [Programs Callì´í•´](#programs-callì´í•´)
  - [ì‹œìŠ¤í…œ ì½œ ì£¼ìš” ê°œë…](#ì‹œìŠ¤í…œ-ì½œ-ì£¼ìš”-ê°œë…)
  - [Effective Addressë€? ì„ í˜•ì£¼ì†Œ](#effective-addressë€-ì„ í˜•ì£¼ì†Œ)
  - [ì»´í“¨í„° êµ¬ì¡° | Instruction Sets](#ì»´í“¨í„°-êµ¬ì¡°-instruction-sets)
  - [Addressing mode](#addressing-mode)

- ì‹¤ìŠµ(í•´ë³´ë©´ì„œ ìµíˆì)
  - [(ì™¸ë¶€ë§í¬) GDBë¡œ ë¦¬ëˆ…ìŠ¤ ì»¤ë„ ë””ë²„ê¹… í•˜ê¸° | Posted Jun 25, 2024](https://gee6809.github.io/posts/debug_kernel/)
  - [(ì™¸ë¶€ë§í¬) QEMU Network ì„¤ì • ë°©ë²• (ê°€ìƒë¨¸ì‹ ë¼ë¦¬ í†µì‹ í•˜ê¸°) | Posted May 16, 2024](https://gee6809.github.io/posts/qemu-network/)
  - [(ì™¸ë¶€ë§í¬) QEMU UEFI í™˜ê²½ìœ¼ë¡œ ë¶€íŒ…í•˜ê¸° (OVMF) | Posted May 23, 2024](https://gee6809.github.io/posts/ovmf/)

<hr />

<hr />

# Quick Start) kernel development in Rust.
This document describes how to get started with kernel development in Rust.
- https://docs.kernel.org/rust/quick-start.html
- https://rust.docs.kernel.org/kernel/index.html
  - https://github.com/Rust-for-Linux/linux/

  - https://rust-for-linux.com/

# Linux ì˜¤ë¦¬ì§€ë‚  ë¬¸ì„œ
- https://www.kernel.org/doc/html/latest/

# fork í•´ì„œ ë¯¸ì¹œë“¯ì´ ë¶„ì„í•´ë³´ì
- https://github.com/YoungHaKim7/linux

# ì•Œê³ ë¦¬ì¦˜ ë° OS & ë„¤íŠ¸ì›Œí¬ ë‹¤ì •ë¦¬ì¤‘..
- https://github.com/YoungHaKim7/Algorithm_Training

# Rust OSDev(Operating System Development in Rust)
- https://rust-osdev.com/

<hr />

# HOWTO do Linux kernel development
- https://www.kernel.org/doc/html/latest/process/howto.html
- ë¦¬ëˆ…ìŠ¤ ì»¤ë„ì„ ë§Œë“¤ê¸° ìœ„í•´ì„  ì´ 3ê°€ì§€ ì±…ì€ í•„ìˆ˜ ë§ˆìŠ¤í„°
  - â€œThe C Programming Languageâ€ by Kernighan and Ritchie [Prentice Hall]
  - â€œPractical C Programmingâ€ by Steve Oualline [Oâ€™Reilly]
  - â€œC: A Reference Manualâ€ by Harbison and Steele [Prentice Hall]



# ìœ ë£Œ ì½˜í…ì¸ (ë‚œì¤‘ì— ê²°ì œí•´ì„œ ë³´ì)[|ğŸ”|](#link)

# (ìœ ë£Œ ì½˜í…ì¸ )Tracking trust with Rust in the kernel[|ğŸ”|](#link)
- https://lwn.net/SubscriberLink/1034603/5dcfecdd5e3af0c2/

# Kernel ìš”ì•½
- How to write Rust in the kernel [Posted June 20, 2025 by daroc][|ğŸ”|](#link)
- This page collects entries in our mini series on how to write Rust code in the Linux kernel.
  - Part 1: details on how to build, test, lint, and format Rust code.
  - Part 2: a close comparison of a PHY driver in Rust and in C.
  - Part 3: a look at the most common bindings Rust drivers will need to use.
- https://lwn.net/Articles/1024941/

# How to write Rust in the kernel: part 1[|ğŸ”|](#link)
[LWN subscriber-only content]
- https://lwn.net/SubscriberLink/1024202/556fa7b3c51d7899/

# How to write Rust in the kernel: part 2
- https://lwn.net/Articles/1025232/

# How to write Rust in the kernel: part 3
- https://lwn.net/Articles/1026694/

# ì»¤ë„ì—ì„œ ì—ëŸ¬ í•¸ë“¤ë§ í•˜ëŠ”ë°©ë²•(Rust)Best practices for error handling in kernel Rust[|ğŸ”|](#link)
- https://lwn.net/Articles/990489/



<hr />

<hr />

<hr />

# Summit-AST translates parsed Apex source code into an abstract syntax tree[|ğŸ”|](#link)
- https://github.com/google/summit-ast

# **[ë§¤ìš° ë¹ ë¥¸ Lexer êµ¬í˜„ ì „ëµ](<https://news.hada.io/topic?id=22140&utm_source=discord&utm_medium=bot&utm_campaign=1480>)**[|ğŸ”|](#link)
- **purple-garden ì–¸ì–´**ë¥¼ ìœ„í•´ **ì´ˆê³ ì† Lexer**ë¥¼ ì§ì ‘ ì„¤ê³„Â·êµ¬í˜„í•œ ì „ëµê³¼ ì‹¤ì¸¡ ì„±ëŠ¥ ë°ì´í„° ê³µìœ   
- **Threaded Lexing(ì í”„ í…Œì´ë¸” ê¸°ë°˜)**, **0ë³µì‚¬Â·ìœˆë„ìš° ë¬¸ìì—´**, **ì¸í„°ë‹**, **bump allocator** ë“± ë‹¤ì–‘í•œ **ìµœì í™” ê¸°ë²•** ì ìš©  
- **í† í° í•´ì‹±**Â·** í‚¤ì›Œë“œ ì‚¬ì „ í•´ì‹œ ë¹„êµ**ë¥¼ í†µí•´ íŒŒì‹± ì†ë„ ê·¹ëŒ€í™”, â€¦

<hr />

# ì‹œìŠ¤í…œ í”„ë¡œê·¸ë˜ë° ê°œìš”[|ğŸ”|](#link)
- https://youtube.com/playlist?list=PLBrGAFAIyf5pIIFQv_U1dG36L5rylTvbx&si=TvM_LyiU9SnDWDzG

# 10ë¶„ ë§Œì— ì„¤ëª…í•˜ëŠ” 7ê°€ì§€ ì‹œìŠ¤í…œ ì„¤ê³„ ê°œë…[|ğŸ”|](#link)
ByteByteGo
- https://youtu.be/Qd9tJ3H_hPE?si=H0rbqnS-sYmnI56M

<hr />

# The source for the Linux kernel used in Windows Subsystem for Linux 2 (WSL2)[|ğŸ”|](#link)
- https://github.com/microsoft/WSL2-Linux-Kernel

# How Does Linux Boot Process Work?[|ğŸ”|](#link)
ByteByteGo
- https://youtu.be/XpFsMB6FoOs?si=giAQss9aqtz40Zp7

# ë¦¬ëˆ…ìŠ¤ ì»¤ë„ ë¶„ì„[|ğŸ”|](#link)
- https://youtu.be/GN3HezzYW8Y?si=GFWwchqYrNw2BbPL

# ë¦¬ëˆ…ìŠ¤ ì»¤ë„ 4Kbytesì•Œëœ°í•˜ê²Œ ì„¤ëª…[|ğŸ”|](#link)
-  Linux Kernel 6.11 | Drama and 15X Part 1
Maple Circuit
  - https://youtu.be/NPJ7DzdysE4?si=oqkQdZww0zCpOwMG

# (2019ë…„ì—ë§Œë“ ê±° _ì˜ìƒëª¨ì•„ë³´ê¸°)Operating Systems | Computer Science Lessons[|ğŸ”|](#link)
- This is a selection of videos about operating systems including memory management and virtual memory, processor addressing modes, process scheduling, an the role of the call stack.
  - https://youtube.com/playlist?list=PLTd6ceoshprdCI72yuKI_VexnJygy-34e&si=pLToMQ5VCA4s23LO

<hr />

# Crafting executables from raw bytes | Kay Lack[|ğŸ”|](#link)
- https://youtu.be/cX5tQJhuNeY?si=6lO7UaboaJ6cXpzk

# Device Manager & Error Code[|ğŸ”|](#link)
 Device Manager is a component of the Microsoft Windows operating system. 
- https://en.wikipedia.org/wiki/Device_Manager

# ë‹¤ì–‘í•œ ì»¤ë„ì˜ ì¢…ë¥˜[|ğŸ”|](#link)
- https://en.wikipedia.org/wiki/Comparison_of_operating_system_kernels

# **[ì¢‹ì€ ì‹œìŠ¤í…œ ì„¤ê³„](<https://news.hada.io/topic?id=22580&utm_source=discord&utm_medium=bot&utm_campaign=1480>)**[|ğŸ”|](#link)
- **ì¢‹ì€ ì‹œìŠ¤í…œ ì„¤ê³„**ë€ ë³µì¡í•´ ë³´ì´ì§€ ì•Šê³  ì˜¤ëœ ê¸°ê°„ ë³„ë‹¤ë¥¸ ë¬¸ì œê°€ ë°œìƒí•˜ì§€ ì•ŠëŠ” í˜•íƒœ  
- **ìƒíƒœ(state)** ë¥¼ ë‹¤ë£¨ëŠ” ê²ƒì´ ì‹œìŠ¤í…œ ì„¤ê³„ì—ì„œ ê°€ì¥ ì–´ë ¤ìš´ ë¶€ë¶„ì´ë©°, ê°€ëŠ¥í•œ í•œ ìƒíƒœë¥¼ ì €ì¥í•˜ëŠ” ì»´í¬ë„ŒíŠ¸ ìˆ˜ë¥¼ ì¤„ì´ëŠ” ë°©í–¥ì´ ì¤‘ìš”  
- ë°ì´í„°ë² ì´ìŠ¤ëŠ” ì£¼ë¡œ ìƒíƒœê°€ ë³´ê´€ë˜ëŠ” ìœ„ì¹˜ë¡œ, **ìŠ¤í‚¤ë§ˆ ì„¤ê³„ì™€ ì¸ë±ì‹±**, ë³‘ëª©â€¦

# **[ë¦¬ëˆ…ìŠ¤ íŒŒì´í”„ëŠ” ì‹¤ì œë¡œ ì–¼ë§ˆë‚˜ ë¹ ë¥¼ê¹Œ?](<https://news.hada.io/topic?id=21623&utm_source=discord&utm_medium=bot&utm_campaign=1480>)**[|ğŸ”|](#link)
- **Linuxì—ì„œ êµ¬í˜„ëœ Unix íŒŒì´í”„ì˜ ì„±ëŠ¥**ì„ ì ì§„ì  ìµœì í™”ë¥¼ í†µí•´ ë¶„ì„í•¨  
- ìµœì´ˆ **ê°„ë‹¨í•œ íŒŒì´í”„ í”„ë¡œê·¸ë¨ì˜ ëŒ€ì—­í­**ì€ ì•½ 3.5GiB/së¡œ ì¸¡ì •ë˜ë©°, í”„ë¡œíŒŒì¼ë§ê³¼ ì‹œìŠ¤í…œì½œ ë³€ê²½ì„ í†µí•´ ì´ë¥¼ 20ë°° ì´ìƒ í–¥ìƒí•˜ëŠ” ê³¼ì •ì„ ë‹¤ë£¸  
- **vmsplice, splice ê°™ì€ Zero-Copy ì‹œìŠ¤í…œì½œ**ì„ í™œìš©í•´ ë¶ˆí•„ìš”í•œ ë°ì´í„° ë³µì‚¬ë¥¼ ì¤„ì´â€¦

# **[Asterinas - ìƒˆë¡œìš´ Linux-í˜¸í™˜ ì»¤ë„ í”„ë¡œì íŠ¸](<https://news.hada.io/topic?id=21594&utm_source=discord&utm_medium=bot&utm_campaign=1480>)**[|ğŸ”|](#link)
- Rustë¡œ ì‘ì„±ëœ **Linux ABI í˜¸í™˜ ì»¤ë„**ë¡œ, â€œ**í”„ë ˆì„ì»¤ë„(framekernel)**â€ ì•„í‚¤í…ì²˜ë¥¼ ì ìš©í•´ **ëª¨ë†€ë¦¬ì‹ê³¼ ë§ˆì´í¬ë¡œì»¤ë„ì˜ ì¥ì ì„ ê²°í•©**í•˜ê³ ì í•¨  
- ëª¨ë“  unsafe ì½”ë“œë¥¼ í•œì •ëœ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë‚´ë¶€ì— ìº¡ìŠí™”í•˜ì—¬, ë‚˜ë¨¸ì§€ ì»¤ë„ ì„œë¹„ìŠ¤ëŠ” ì•ˆì „í•œ Rust ì¶”ìƒí™”ë¡œ ê°œë°œ ê°€ëŠ¥í•˜ê²Œ ì„¤ê³„í•´ **ë©”ëª¨ë¦¬ ì•ˆì „ì„±ê³¼ ë‹¨ìˆœí•œ ê³µìœ  ë©”â€¦

# **[GNâº: Asterinas - Rustë¡œ ì‘ì„±ëœ Linux í˜¸í™˜ ABI ì œê³µ OS ì»¤ë„](<https://news.hada.io/topic?id=17283&utm_source=discord&utm_medium=bot&utm_campaign=1480>)**[|ğŸ”|](#link)
- AsterinasëŠ” _ì•ˆì „ì„±_, _ì†ë„_, _ë²”ìš©ì„±_ ì„ ê°–ì¶˜ OS ì»¤ë„ë¡œ, _Linux í˜¸í™˜_ ABIë¥¼ ì œê³µ  
- Linuxë¥¼ ëŒ€ì²´í•  ìˆ˜ ìˆìœ¼ë©°, _ë©”ëª¨ë¦¬ ì•ˆì „ì„±_ ê³¼ _ê°œë°œì ì¹œí™”ì„±_ ì„ í–¥ìƒì‹œí‚´  
  - Rustë¥¼ ìœ ì¼í•œ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ë¡œ ì‚¬ìš©í•˜ê³ , _unsafe Rust_ ì˜ ì‚¬ìš©ì„ ìµœì†Œí™”í•˜ì—¬ ëª…í™•íˆ ì •ì˜ëœ ì‹ ë¢° ì»´í“¨íŒ… ê¸°ë°˜(TCB)ìœ¼ë¡œ ì œí•œí•¨ìœ¼ë¡œì¨...

# OSle - ë¶€íŠ¸ ì„¹í„°ì— ë“¤ì–´ê°€ëŠ” 510ë°”ì´íŠ¸ ì§œë¦¬ ì´ˆì†Œí˜• OS (shikaan.github.io)[|ğŸ”|](#link)
13P by xguru 2ì¼ì „ | â˜… favorite | ëŒ“ê¸€ 1ê°œ
510 ë°”ì´íŠ¸ì•ˆì— ì‰˜, íŒŒì¼ ì‹œìŠ¤í…œ, í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ ê¸°ëŠ¥ì„ ë‹´ì€ x86 ì–´ì…ˆë¸”ë¦¬ ê¸°ë°˜ ë¶€íŠ¸ì„¹í„° ìš´ì˜ì²´ì œ
- https://news.hada.io/topic?id=20683

# **[Hyperlight WASM: ë¹ ë¥´ê³ , ì•ˆì „í•˜ê³  OS-Free](<https://news.hada.io/topic?id=20219&utm_source=discord&utm_medium=bot&utm_campaign=1480>)**[|ğŸ”|](#link)
- Hyperlight Wasmì€ Microsoftê°€ CNCFì— ê¸°ë¶€í•œ **ì´ˆê²½ëŸ‰ ê°€ìƒ ë¨¸ì‹ (VM)** ê¸°ìˆ  Hyperlightì˜ ìµœì‹  í™•ì¥ ë²„ì „ìœ¼ë¡œ, **WebAssembly(Component Model ê¸°ë°˜)** ì›Œí¬ë¡œë“œë¥¼ ë¹ ë¥´ê³  ì•ˆì „í•˜ê²Œ ì‹¤í–‰í•¨  
- ì „í†µì ì¸ VMê³¼ ë‹¬ë¦¬ OSë‚˜ ê°€ìƒ ë””ë°”ì´ìŠ¤ ì—†ì´ **ë©”ëª¨ë¦¬ ìŠ¬ë¼ì´ìŠ¤ì™€ CPUë§Œ ë…¸ì¶œ**, 1~2msì˜ ë¹ ë¥¸ ë¶€íŒ… ì‹œê°„ ì œê³µ  
- ë‹¤ì–‘â€¦  

# ë¦¬ëˆ…ìŠ¤ ì‹œìŠ¤í…œ ì„¤ê³„ | jihunback[|ğŸ”|](#link)
- https://youtu.be/96FVy_h4VY8?si=WlnKdYFdVmR35hNY

# (241119)Miguel Ojeda (Rust for Linux): KEYNOTE | RustConf 2024 | Rust Foundation[|ğŸ”|](#link)
- https://youtu.be/FRMJzNYut4g?si=0QYe24x2wmCpv6Wn

# OSì½”ë”©ì„ í•œë‹¤ëŠ”ê±´ ì½”ë”©ì˜ ì •ì ì— ì„œ ìˆëŠ”ê±°ë‹¤. ë‚˜ë¨¸ì§€ ì½”ë”©ì€ OSì½”ë”©ì˜ ì—´í™”íŒ ã…‹ã…‹[|ğŸ”|](#link)
-  [ì¸í„°ë·°#2] ë¦¬ëˆ…ìŠ¤ ì»¤ë„ ë°°ìš°ë ¤ë©´ ì–¼ë§ˆë‚˜ ê±¸ë ¤ìš”? | [ì˜¤ì œì´ íŠœë¸Œ]OJ Tube
  - https://youtu.be/N7rk_qDivVQ?si=xDXNrAlSPpKyDa-l

# ëŸ¬ìŠ¤íŠ¸ë¡œ ì¸í„°í”„ë¦¬í„° ë§Œë“¤ë©° ì»´íŒŒì¼ëŸ¬ ë§Œë“¤ê¸° ê¸°ì´ˆ ì¡ê¸°[|ğŸ”|](#link)
- https://github.com/Polanas/monkey_interpreter

# (250210) Rewriting the future of the Linux essential packages in rust | Sylvestre Ledru[|ğŸ”|](#link)
- https://youtu.be/cXf31nFPo0U?si=Zxs6YQCZDIa1lMFX

# (êµ¬ê¸€ ê°œë°œì 250226)Rust project goals 2024: Stabilizing Rust in the Linux Kernel - Alice Ryhl | Rust Nation UK[|ğŸ”|](#link)
- https://youtu.be/J2M3EGUgq0c?si=PvQPW2asgIrf2dXC

# **[GNâº: 1,000ì¤„ë¡œ ìš´ì˜ì²´ì œ êµ¬í˜„í•˜ê¸°](<https://news.hada.io/topic?id=18639&utm_source=discord&utm_medium=bot&utm_campaign=1480>)**[|ğŸ”|](#link)
- ì´ ì±…ì€ ì‘ì€ ìš´ì˜ì²´ì œë¥¼ ì²˜ìŒë¶€í„° ë‹¨ê³„ë³„ë¡œ êµ¬ì¶•í•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í•¨  
- ìš´ì˜ì²´ì œ(OS)ë‚˜ ì»¤ë„ ê°œë°œì´ë¼ëŠ” ë§ì— ê²ë¨¹ì„ ìˆ˜ ìˆì§€ë§Œ, OSì˜ ê¸°ë³¸ ê¸°ëŠ¥(íŠ¹íˆ ì»¤ë„)ì€ ë†€ëë„ë¡ ê°„ë‹¨í•¨  
- Linuxë„ ì²˜ìŒì—ëŠ” 8,413ì¤„ì˜ ì½”ë“œë¡œ ì‹œì‘í–ˆìœ¼ë©°, ì˜¤ëŠ˜ë‚ ì˜ Linux ì»¤ë„ì€ ë§¤ìš° í¬ì§€ë§Œ, ì·¨ë¯¸ í”„ë¡œì íŠ¸ì²˜ëŸ¼ ì‘ì€ ì½”ë“œë² ì´ìŠ¤ë¡œ ì‹œì‘í–ˆ...

# Watch Linux kernel developer write a USB driver from scratch in just 3h for Apple Xserve front-panel[|ğŸ”|](#link)
Bits inside by RenÃ© Rebe
- https://youtu.be/IXBC85SGC0Q?si=QKO2Ndz-zc20uWiq

# **[gccrs: Rustë¥¼ ìœ„í•œ ëŒ€ì²´ ì»´íŒŒì¼ëŸ¬](<https://news.hada.io/topic?id=17681&utm_source=discord&utm_medium=bot&utm_campaign=1480>)**[|ğŸ”|](#link)
- `gccrs`ëŠ” GCC í”„ë¡œì íŠ¸ì˜ ì¼í™˜ìœ¼ë¡œ ê°œë°œ ì¤‘ì¸ ëŒ€ì²´ Rust ì»´íŒŒì¼ëŸ¬ì…ë‹ˆë‹¤.  
- ì´ í”„ë¡œì íŠ¸ëŠ” GNU ì»´íŒŒì¼ëŸ¬ ì»¬ë ‰ì…˜ ë‚´ì—ì„œ Rustë¥¼ ì§€ì›í•˜ëŠ” ê²ƒì„ ëª©í‘œë¡œ í•˜ë©°, `rustc`ì™€ ë™ì¼í•œ ë™ì‘ì„ ëª©í‘œë¡œ í•©ë‹ˆë‹¤.  
- ì£¼ìš” ëª©í‘œëŠ” íŠ¹íˆ LLVMì´ ì§€ì›í•˜ì§€ ì•ŠëŠ” í”Œë«í¼ì—ì„œ Rustë¥¼ ì»´íŒŒì¼í•  ìˆ˜ ìˆëŠ” ëŒ€ì•ˆì„ ì œê³µí•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.  
...

# uutils/coreutils[|ğŸ”|](#link)
Cross-platform Rust rewrite of the GNU coreutils
- https://github.com/uutils/coreutils

# 2024 LLVM Developers' Meeting - Rust â¤ï¸ LLVM[|ğŸ”|](#link)
- https://youtu.be/Kqz-umsAnk8?si=NLogEP1h-CXUSXPy

# kata-containers/kata-containers[|ğŸ”|](#link)
- Kata Containers is an open source project and community working to build a standard implementation of lightweight Virtual Machines (VMs) that feel and perform like containers, but provide the workload isolation and security advantages of VMs. 
- https://katacontainers.io/

# **[Bazel: ì–¸ì œ ì‚¬ìš©í•´ì•¼ í• ê¹Œ? (2023)](<https://news.hada.io/topic?id=18232&utm_source=discord&utm_medium=bot&utm_campaign=1480>)**[|ğŸ”|](#link)
- Bazelì€ Googleì´ ëŒ€ê·œëª¨ ëª¨ë…¸ë ˆí¬ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ë¹Œë“œí•˜ê¸° ìœ„í•´ ê°œë°œí•œ ì˜¤í”ˆ ì†ŒìŠ¤ ë¹Œë“œ ì‹œìŠ¤í…œ  
- ë³µì¡í•œ í”„ë¡œì íŠ¸ë¥¼ ì •í™•í•˜ê³  ë¹ ë¥´ê²Œ ë¹Œë“œí•˜ë©°, íŠ¹íˆ ëŒ€ê·œëª¨ ì½”ë“œë² ì´ìŠ¤ì™€ ë‹¤ì¤‘ ì–¸ì–´ ì¢…ì†ì„±ì„ ë‹¤ë£° ë•Œ íš¨ê³¼ì   
- Bazelì˜ í•µì‹¬ ê°œë…  
  - **ì •í™•ì„± ê¸°ë°˜ì˜ ì†ë„**: Bazelì€ ë¹Œë“œë¥¼ ìˆœìˆ˜ í•¨ìˆ˜ë¡œ ê°„ì£¼, ë™ì¼í•œ ì…ë ¥...

# **[í”í•œ ì»´íŒŒì¼ëŸ¬ ì˜¤í•´ë“¤](<https://news.hada.io/topic?id=18194&utm_source=discord&utm_medium=bot&utm_campaign=1480>)**[|ğŸ”|](#link)
### ì»´íŒŒì¼ëŸ¬ ìµœì í™”ì— ëŒ€í•œ ì˜¤í•´  
  
* **ìµœì í™”ëŠ” ìµœì ì˜ í”„ë¡œê·¸ë¨ì„ ì œê³µí•œë‹¤?**   
    * ì»´íŒŒì¼ëŸ¬ëŠ” ìµœì ì˜ í”„ë¡œê·¸ë¨ì„ ìƒì„±í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, ë‹¨ìˆœí™”ëœ í”„ë¡œê·¸ë¨ì„ ê°œì„ í•˜ëŠ” ê²ƒì„ ëª©í‘œë¡œ í•©ë‹ˆë‹¤.  
    * ì½”ë“œ í¬ê¸° ìµœì í™”ëŠ” ê°€ëŠ¥ì„±ì´ ìˆì§€ë§Œ, ì‹¤í–‰ ì‹œê°„ ìµœì í™”ëŠ” ì¸¡ì •ì˜ ì–´ë ¤ì›€, ìµœì  ë¶€ë¶„ êµ¬ì¡°ì˜ ë¶€ì¬, í•˜ë“œ...

# **[Rust ê¸°ë°˜ Redox OS, RISC-V ì§€ì› ë° Raspberry Pi 4ì—ì„œ ë¶€íŒ… ê°€ëŠ¥í•´ì§](<https://news.hada.io/topic?id=17622&utm_source=discord&utm_medium=bot&utm_campaign=1480>)**[|ğŸ”|](#link)
- Redox OSëŠ” Rustë¡œ ì‘ì„±ëœ ì˜¤í”ˆ ì†ŒìŠ¤ ìš´ì˜ ì²´ì œ í”„ë¡œì íŠ¸  
- RISC-Vê°€ ì´ì œ Redox OSì˜ ì§€ì› ëŒ€ìƒì´ ë¨. QEMU ì—ë®¬ë ˆì´í„°ì—ì„œ ë°ìŠ¤í¬í†±ê³¼ í•¨ê»˜ Redox OSë¥¼ ì‹¤í–‰í•  ìˆ˜ ìˆëŠ” ìˆ˜ì¤€ì— ì´ë¦„  
- Raspberry Pi 4ì—ì„œ Redox OSê°€ ë¶€íŒ…ë¨. ë¡œê·¸ì¸ í™”ë©´ê¹Œì§€ëŠ” ì§„ì…í•˜ì§€ë§Œ USB ì§€ì› ë“± ë‹¤ë¥¸ ê¸°ëŠ¥ì€ ì•„ì§ ì™„ì„±ë˜ì§€ ì•ŠìŒ  
- R...

# Systems Software for Linux with Rust â€“ Interview with Zeeshan Ali Khan[|ğŸ”|](#link)
 | timClicks
- https://youtu.be/atE94jvfVuA?si=7BgYxVChN5hq7_Hn

<hr />

# ì¤‘êµ­ ì•ˆë“œë¡œì´ë“œ ë²„ë¦¬ê³  ì „í™˜ ì„±ê³µí•œ HarmonyOS NEXT(241023)[|ğŸ”|](#link)

- [241023_GNâº: í™”ì›¨ì´, HarmonyOS NEXT ì¶œì‹œë¡œ ì•ˆë“œë¡œì´ë“œì™€ ê³µì‹ ê²°ë³„ (theregister.com)](https://news.hada.io/topic?id=17399)

- HarmonyOS NEXT (Chinese: é¸¿è’™æ˜Ÿæ²³ç‰ˆ; pinyin: HÃ³ngmÃ©ng XÄ«nghÃ©bÇn)
is a proprietary distributed operating system and a major iteration of HarmonyOS, developed by Huawei to support only HarmonyOS native apps.
  - https://en.m.wikipedia.org/wiki/HarmonyOS_NEXT

- HarmonyOS ìµœê·¼ ìˆ˜ì • ì‹œê°: 2025-03-09 03:51:12
  - https://namu.wiki/w/HarmonyOS

<hr />



# **[GNâº: Windows NT vs. Unix: ì„¤ê³„ ë¹„êµ](<https://news.hada.io/topic?id=16692&utm_source=discord&utm_medium=bot&utm_campaign=1480>)**[|ğŸ”|](#link)
- https://news.hada.io/topic?id=16692&utm_source=discord&utm_medium=bot&utm_campaign=1480
- NTëŠ” ì¢…ì¢… "ë§¤ìš° ì§„ë³´ëœ" ìš´ì˜ ì²´ì œë¡œ í‰ê°€ë°›ì•˜ì§€ë§Œ ê·¸ ì´ìœ ë¥¼ ì˜ ëª°ëìŒ  
  - 2023ë…„ ë§, 'Inside Windows NT' 1íŒì„ ì½ê³  NTì™€ Unixë¥¼ ë¹„êµí•˜ê¸°ë¡œ í•¨  
  - NT(1993ë…„ 7ì›”)ì™€ ë‹¹ì‹œ Unix ì‹œìŠ¤í…œ(4.4BSD, ë¦¬ëˆ…ìŠ¤ 1.0)ì˜ ì„¤ê³„ë¥¼ ë¹„êµí•œ ê²ƒì„  
  - Unix ì „ë¬¸ê°€ë¡œì„œ NTëŠ” ì˜ ëª¨ë¥´ê¸°ì— NTì˜ ì°¨ì´ì  ìœ„ì£¼ë¡œ ì„œìˆ í•¨  
...

<hr>


# (ì»´íŒŒì¼ëŸ¬ ë§Œë“œëŠ” ì±…ìœ¼ë¡œ ìœ ëª…í•œê±° í•˜ë„¤ êµ¿)Implementing a Lox interpreter in Rust | Jon Gjengset[|ğŸ”|](#link)
- https://youtu.be/mNOLaw-_Buc?si=U80ttpOVb_xGVcWK

<hr>

# OSê¸°ë³¸ ê°œë…ì¡ê¸°[|ğŸ”|](#link)
- ëª¨ì•„ë³´ê¸° 1 ( 1.2 OPERATING SYSTEM (Complete Playlist) | KnowledgeGATE by Sanchit Sir)
  - https://youtube.com/playlist?list=PLmXKhU9FNesSFvj6gASuWmQd23Ul5omtD&si=m6o65lgTsMBMPVK_

- ë‹¤ë¥¸ê±° 2(4ì‹œê°„30ë¶„_í•œë°©ì—)(Introduction to Operating System | Full Course for Beginners Mike Murphy ğŸŒš Lecture for Sleep & Study | LECTURES FOR SLEEP & STUDY)
  - https://youtu.be/dOiA2nNJpc0?si=JRjWo2OdPwV1wBJ5

- ì†ê¸€ì”¨ë¼ ã…œã…œ ê¸€ìê°€ ì˜ ì•ˆë³´ì„(Operating Systems Course for Beginners | freeCodeCamp.org)
  - https://youtu.be/yK1uBHPdp30?si=ft4gjiJOvW2IH13-


```
00:02 Comprehensive operating system course covering fundamental and advanced concepts.
02:41 Operating Systems Course overview and guidelines
07:28 ALU performs arithmetic and logical functions.
09:44 Operating system loads the executable file from hard disk to main memory for CPU execution.
14:33 Operating system acts as a resource manager
16:51 Operating system controls everything in the computer.
21:07 Operating system acts as a resource manager and government in controlling program applications.
23:05 Uni programming OS allows only one program in memory, leading to CPU idle time.
27:26 Multiprocessor systems run one program at a time
29:33 Schematic view of multiprogramming operating system
33:30 Difference between uniprocessor and multiprocessor systems
35:22 Multiprogramming increases CPU utilization and efficiency
39:25 Process Management in Operating Systems
41:30 Secondary storage devices need to be DMA compatible and support address translation for efficient data transfer.
45:49 Privileged processes in operating systems
47:57 Mode shifting is necessary for user applications to access OS kernel level services.
52:05 Multiprogramming increases CPU utilization and efficiency.
53:47 Architectural requirements for operating systems
57:41 Operating System Booting and Memory
59:39 Non-preemptive processes have better response time
1:03:42 Learn about mode shifting via API and SCI
1:05:57 Understanding the difference between print F in header and library files
1:10:28 Shift mode from user to kernel to access fork services
1:12:39 SVC and Interrupts in Operating Systems
1:16:58 Understanding how mode shifting is essential in operating systems.
1:18:51 Operating system mode shifting and system calls
1:22:39 Understanding kernel mode and user mode operation
1:24:33 Explanation of child process creation using Fork
1:28:52 Difference between a program and a process
1:30:58 Compilation process converts high-level code into low-level instructions
1:35:20 Dynamic array implementation in C using Maloc
1:37:31 Process is the program in execution using computer resources.
1:41:34 Program consists of instruction and data, with data types static and dynamic.
1:43:36 Activation records in function calls
1:47:40 Learning VSS extension and process operations
1:49:40 Transition diagram states and process attributes
1:53:47 Understanding Process Control Block (PCB) and Process Lifetime Stages
1:56:02 Understanding resource deallocation and process states
2:00:15 Operating systems shift processes from main memory to hard disk to manage clutter.
2:02:35 Process transitions from ready to waiting to running state in an OS
2:06:58 Processes go directly to running state with no ready stage
2:09:16 Resource allocation and deallocation in main memory
2:13:42 Transferring processes from Main memory to disk
2:15:47 Ready state is the most desirable for suspension
2:20:07 Understanding process states in Operating Systems
2:22:03 Processes transitioning in the operating system
2:25:53 Transition from suspended block to ready state involves swapping/loading to bring process back to main memory
2:27:46 Operating system resumes process based on resource availability
2:32:03 Explaining the concept of block and device queues in memory management.
2:34:12 Overview of Scheduling Cues in Operating Systems
2:38:16 Dispatcher controls CPU execution for selected process.
2:40:23 Schedulers in Operating Systems
2:44:46 Process Switching
2:46:53 Overview of schedulers and dispatcher in Operating Systems
2:50:58 Understanding arrival time and waiting time in an Operating System
2:52:48 Understanding process state transitions and timing
2:56:56 Preemptive scheduling allows for infinite possible ways to schedule processes.
2:58:50 Schedule Length Calculation
3:02:38 Understanding turnaround time in process scheduling
3:04:32 Discussing scheduling and its types
3:08:44 Introduction to Process Scheduling
3:10:49 The Gant chart always starts from zero.
3:15:02 Calculating waiting time in Operating Systems
3:17:00 Scheduling processes based on arrival time and execution time
3:21:04 Understanding Gantt chart and CPU idleness
3:23:07 Calculate percentage CPU idleness over schedule length
3:27:11 Understanding the life cycle of a process in Operating Systems
3:29:22 Process scheduling involved loading from ready to running via dispatcher
3:33:38 Understanding process scheduling and completion times in operating systems
3:35:48 Understanding the distinction between transit time and waiting time is crucial.
3:40:17 Calculate waiting time from chart, not formula
3:42:22 Understanding process transition from ready to running and then block in Operating Systems
3:46:38 Process scheduling and termination process in an operating system
3:48:37 Dispatcher time and process scheduling overview
3:52:46 Tips for solving process transition questions
3:54:47 Understanding CPU idleness and scheduling processes
3:58:47 Calculate CPU overhead for given process scheduling
4:00:45 Homework questions for CPU efficiency and scheduling overhead
4:04:54 Process transitions in an operating system
4:06:48 Scheduling processes with single IO device
4:10:32 Shortest Job First (SJF) prioritizes processes with the least burst time.
4:12:26 Scheduling in non-preemptive algorithms
4:16:18 Scheduling processes based on burst time and process ID.
4:18:09 Understanding the shortest job first (SJF) algorithm and its preemptive version (SRTF)
4:22:02 SRTF scheduling preempt shorter burst times
4:23:49 Understanding Preemption in SRTF Scheduling
4:27:34 SRTF scheduling algorithm involves checking every time a new process arrives
4:29:33 Scheduling and preemption in operating systems
4:33:32 SGF and SRTF algorithms are optimal
4:35:39 Calculating optimal average waiting time using Shortest Job First algorithm (SJF)
4:39:28 Calculate waiting time for processes based on scheduling order.
4:41:23 Predicting burst time using static and dynamic techniques
4:45:48 Explaining recurrence relation and initial guess concept
4:47:43 Prediction techniques for CPU burst time
4:51:55 Processes with high response ratio are given priority in HRR algorithm
4:54:02 Discussing unfairness in process scheduling based on bus time
4:58:11 Longest remaining time first (LRTF) algorithm is the opposite of SRTF, scheduling the longest process first.
5:00:13 SRTF scheduling prioritizes processes based on remaining burst time
5:04:32 Processes scheduling based on remaining burst time and process ID
5:06:23 Scheduling based on burst time and process IDs
5:10:04 Scheduling jobs using Shortest Job First algorithm
5:12:03 Introduction to priority-based scheduling algorithm
5:16:06 Priority scheduling in Operating Systems
5:18:10 Scheduling processes based on priority levels
5:22:12 Scheduling based on priority and completion time
5:24:08 Understanding the priority and scheduling of processes
5:28:10 Introduction to Round Robin algorithm
5:30:13 In round robin scheduling, processes have to leave after the time quantum
5:34:20 Scheduling multiple processes based on time Quantum
5:36:28 Scheduling new and preemptive processes
5:40:20 Scheduling processes based on arrival times and time quantum in round-robin algorithm.
5:42:16 Schedule of processes in the RQ
5:46:22 Efficiency drops to zero with small time Quantum in operating systems
5:48:32 Determining the suitable time quantum for round-robin scheduling
5:53:05 Understanding the implications of different values of Q in the context of CPU scheduling
5:55:39 Understanding CPU scheduling and time quantum
6:00:00 Explaining CPU scheduling and response time calculation
6:02:18 Calculation of response time in CPU scheduling
6:06:37 Different scheduling algorithms applied to different queues based off priorities
6:08:44 Processes penalized based on running time
6:12:46 Interprocess communication (IPC) is essential for communication between processes.
6:14:48 Synchronization is performing an agreed action.
6:19:00 Synchronization is the coordination of concurrent processes.
6:21:07 Synchronization in Operating Systems
6:25:20 Understanding the producer-consumer problem
6:27:29 Understanding process synchronization and deadlock
6:31:49 Understanding preemption and process execution
6:33:49 Understanding race conditions and synchronization
6:38:03 Importance of Correct Results in Processes
6:40:09 Producer places item onto buffer when buffer is not full
6:44:25 Understanding the circular buffer concept in operating systems.
6:46:20 Implementation of producer and consumer in C language
6:50:35 Stagnant water and mosquitoes are the main culprits for malaria spreading.
6:52:32 Synchronization requires critical sections and race conditions.
6:56:49 Security guard manages access to critical section
6:58:55 Requirements of Critical Section Problem

7:03:18 Critical section must have bounded waiting for interested processes.
7:05:23 Differentiating synchronization mechanisms as solutions or not
7:09:41 Introduction to lock variable as a synchronization mechanism
7:11:56 Implementing locking mechanism for mutual exclusion
7:16:17 Understanding the critical section and entry process.
7:18:41 Explanation of lock variable implementation
7:23:14 Preemption and lock value changes in a multi-process scenario
7:25:27 Importance of Lock in Ensuring Mutual Exclusion
7:29:39 Lock variable leads to wastage of CPU time.
7:31:52 Importance of critical section and preventing wastage of CPU cycles
7:36:22 Strictly alternate process execution for critical section access
7:38:28 Understanding mutual exclusion and the turn variable
7:42:40 Uninterested processes hinder the progress of interested processes
7:44:41 Explanation of mutual exclusion and bounded waiting in synchronization mechanisms
7:48:53 Concept of flag and turn for process synchronization
7:51:03 Understanding the concept of turn and flag in the context of processes.
7:55:26 Peterson solution is about the critical section and updating turn value.
7:57:38 Discussing process scheduling and completion of sections
8:01:49 Peterson solution ensures non-interested processes do not hinder progress
8:03:57 Peterson solution ensures mutual exclusion
8:08:08 Ensuring mutual exclusion and progress in operating systems.
8:10:16 Understanding the impacts of initialization on process turns
8:14:35 Decker's algorithm in operating systems
8:16:45 Algorithm provides mutual exclusion and progress
8:21:01 Explanation of Deadlock in Operating Systems
8:23:11 Discussion on bounded waiting and strict alternation
8:27:15 Discussing Test and Set Lock functionality
8:29:27 Explanation of TSL operation and its impact on critical section execution.
8:33:24 Swap mechanism based on lock and key ensures atomic execution
8:35:20 Understanding the process of swapping using a temporary variable.
8:39:16 Swap mechanism guarantees Mutual exclusion and progress
8:41:17 Test and set provides mutual exclusion
8:45:22 Priority inheritance solves deadlock in critical sections
8:47:30 Fetch and add X, I is an atomic read modify write instruction.
8:51:39 Understanding synchronization mechanisms and problem-solving
8:53:35 Understanding how L=0 and L!=1 affect log value increments.
8:57:25 Demonstration of Mutual exclusion and prevention of overflow
8:59:14 Preemption strategy in entry section
9:03:06 Understanding overflow in processes
9:05:15 FCFS doesn't suffer from starvation except for infinite loops
9:09:32 Sleep and wake up is a blocking mechanism in multiprocess solutions
9:11:33 Solving the producer-consumer problem using non-busy waiting solution
9:15:38 Implementing consumer functionality in operating systems
9:17:37 Understanding preemptive process scheduling
9:21:38 Semaphore - Definition and Types
9:23:51 Explanation of the down operation in kernel mode
9:28:16 Positive value of SEMA 4 indicates successful down operations, negative value indicates blocked processes
9:30:09 Understanding how sema4 provides Mutual exclusion
9:34:03 The objective of up operation is to wake up a sleeping process
9:36:01 Understanding the conditions for waking up processes
9:40:04 Using SEMA 4 helps manage concurrent requests effectively.
9:42:10 Managing Processes with Counting Semaphores
9:46:05 Understanding down operation in binary semaphores
9:48:05 Understanding the process blocking and synchronization
9:51:58 Understanding value changes in critical sections
9:53:57 Explanation of binary semaphore operations
9:58:13 Semaphore 4 and its operations
10:00:07 Ensuring mutual exclusion and progress in critical section
10:04:17 Preemption in semaphores can lead to deadlock.
10:06:27 Preempting processes to prevent deadlock
10:10:53 Process synchronization using down and up operations
10:13:07 Implication of strict alternation for mutual exclusion
10:17:22 Demonstrating mutual exclusion and deadlock in operating systems.
10:19:24 Understanding a scenario leading to deadlock and semaphore initialization
10:23:44 Explaining the limitations of processes without a while loop.
10:26:03 Determining minimum and maximum value of variable C in a concurrent process scenario
10:30:29 Understanding deadlock in operating systems
10:32:29 Discussing synchronization and mutual exclusion in operating systems.
10:36:25 Concurrency issues in race condition
10:38:41 Processes changing values and storing them
10:42:56 Understanding implementation using semaphores
10:44:56 Operating System synchronization in producer-consumer scenario
10:49:16 Understanding the deadlock and order importance in synchronization problems.
10:51:21 Understanding synchronization problem in operating systems
10:55:26 Producer adds item to buffer but consumer can't consume
10:57:32 Consumer removing one item at a time from buffer
11:01:20 Reader Writer problem and its solution using semaphores
11:03:29 Starvation of writers in database access
11:07:47 Database locking mechanism for readers and writers
11:09:55 Understanding the use of mutex and database for accessing the critical section.
11:14:10 Solving reader-writer problem using Mutex
11:16:05 Semaphore used to solve reader-writer problem
11:19:55 Implementation of Dining Philosopher problem
11:21:59 Philosophers sharing forks for eating efficiency
11:26:06 Preventing deadlocks by changing philosopher pattern
11:28:07 Preventing deadlock by changing paths
11:32:26 Statements can be executed concurrently if they are independent.
11:34:49 Understanding concurrency and parallelism
11:39:01 Concurrency and parallelism in operating systems
11:41:05 Understanding concurrent execution in Operating Systems
11:45:28 Understanding read set and write set for concurrent statements
11:47:38 Understanding the difference between sequential and concurrent execution using pair begin and pair end
11:51:57 Dependent nodes cannot always be considered concurrent.
11:54:10 Exploration of handling dependencies and contradictions in program execution
11:58:17 Acquiring keys in executing statements

12:00:23 Understanding the dependency between locks in executing sequence of commands.
12:04:41 Understanding key requirements for locks in the given scenario.
12:06:52 Understand the importance of valid sequences in executing concurrent tasks
12:11:11 Updating values of x and y in a sequence
12:13:30 Understanding binary semaphore and sequentiality in execution.
12:17:51 Understanding the concepts of Fork and Join in operating systems.
12:20:00 Explaining how to branch instructions in Fork
12:23:48 Understanding control flow in Operating Systems.
12:25:53 The process synchronization section is over.
12:29:45 Value of counter depends on thread execution
12:31:40 Deadlock is when two or more processes are waiting for an event that is never going to happen.
12:35:51 Deadlock explained with a meme
12:38:00 Deadlock occurs when a process is blocked forever due to resource unavailability.
12:42:14 Four necessary conditions for deadlock
12:44:24 Circular wait is not a sufficient condition for deadlock
12:48:49 Understanding resource allocation and blocking in Operating Systems
12:50:53 Preventing Deadlocks by Resource Release
12:55:03 Deadlock prevention strategies are crucial for critical operating systems.
12:57:11 Deadlock prevention negates necessary conditions
13:01:32 Efficient resource utilization through protocol 2
13:03:52 Forceful preemption and self preemption prevent deadlock
13:08:11 Resource preemption is crucial for avoiding circularity and maintaining linearity.
13:10:07 Understanding the necessity of cycles in resource allocation
13:14:27 Resource allocation graph aims to maintain a safe state
13:16:40 Understanding safe and unsafe states in resource allocation
13:20:51 Understanding Safety Algorithm and Resource Request Algorithm Basics
13:23:36 Understanding resource allocation in operating systems
13:28:25 Resource allocation and satisfaction process summarized.
13:30:35 Understanding the Banker algorithm for multiple resources with multiple instances.
13:34:55 Proving the existence of multiple CF sequences
13:37:07 Multiple safe sequences can exist with Banker's algorithm
13:41:32 Updating resource allocation and running the safety algorithm
13:43:54 Resource allocation and availability
13:48:10 Applying safety algorithm to check system state based on resource values
13:50:28 Satisfied the need for resources
13:54:59 Deadlock in single instance and multi-instance resource allocation
13:57:13 Achieving safe state by satisfying process requests
14:01:40 Resource preemption and process recovery
14:03:49 Deadlock avoidance strategies
14:08:12 Maximum resources for deadlock is 36, minimum for deadlock freedom is 37
14:10:22 Understanding unsafe state vs deadlock in resource allocation graphs
14:15:02 Ensure system can satisfy minimum resource requests to avoid deadlock
14:17:05 Resource allocation using Bankers algorithm
14:21:23 Understanding the hierarchy of memory sizes and functions of RAM in operating systems
14:23:44 Memory size calculation based on number of words and word size
14:27:57 Understanding data representation using bits and bytes
14:30:11 Explaining memory size in bits and bytes
14:34:40 Addressing Memory Blocks in Operating Systems
14:36:45 Understanding memory size and word addressing
14:40:51 Understanding the purpose and operation of the bus, chip select, and address bus in a computer system
14:42:57 Static and dynamic loading in operating systems
14:47:13 Resolving External References
14:49:25 Linker module fills up blank addresses in program code.
14:53:53 Dynamic linking allows for flexibility and code reusability
14:56:10 Difference between static and dynamic linking
15:00:45 Understanding different types of binding in Operating Systems.
15:03:02 Static and dynamic binding in operating systems
15:07:23 Address binding provides relocation flexibility at runtime.
15:09:33 Static binding vs. dynamic binding
15:13:44 Memory management fundamentals from older theories
15:15:54 Memory manager goals to minimize wastage and utilize memory effectively
15:20:20 Understanding memory overlay and its application
15:22:41 Explaining partitioning in Operating Systems.
15:26:54 Base plus limit architecture to ensure protection
15:29:05 Overview of old and new techniques in Operating Systems
15:33:22 Fixed partition leads to internal fragmentation and limited multiprogramming.
15:35:25 Dynamic partitioning allows for flexible memory allocation
15:39:35 External Fragmentation and Solutions
15:41:39 Resolve external fragmentation by reallocating memory and creating a bigger free hole
15:45:35 Variable partitioning and best fit allocation in memory systems
15:47:35 Memory allocation strategies
15:51:55 Operating Systems manages process table and memory partitions
15:54:09 Process table size calculation for 500 processes.
15:58:31 Scheduling and memory management using FCFS
16:00:32 Explaining memory allocation based on program size
16:04:24 Understanding non-continuous allocation
16:06:27 Introduction to Variable Partitioning for memory management
16:10:41 Differences between logical address and physical address
16:12:53 Memory management involves converting logical addresses to physical addresses.
16:17:11 Memory management unit handles address translation
16:19:26 Pages and Page Size Calculation
16:24:18 Understanding page offset and page number in memory addressing
16:26:37 Logical address format explained with page number and page offset
16:31:02 Understanding the concept of frames and pages in memory management.
16:33:13 Understanding logical address space and physical address space division
16:37:42 Finding physical address space using page size and frame size.
16:39:53 Understanding address translation in Operating Systems
16:44:06 Page table contains the frame number where pages are stored.
16:46:21 Understanding Page Table in Operating Systems
16:50:37 Paging technique for accessing physical memory
16:52:51 Understanding virtual memory and page table size
16:57:30 Calculating page offset and physical address space size in a computer system using paging technique
16:59:47 Determining page size and number of pages in simple paging technique.
17:04:07 Page table size calculation and performance impacts
17:06:20 Main memory access time (M) is crucial for CPU operations
17:10:46 Cache memory access time is less than main memory access time
17:12:40 Introduction to cache memory and effective access time
17:16:55 Defined hit and miss ratio for effective memory access time
17:19:12 Understanding TLB and PSC in CPU processing
17:23:30 Optimizing memory access using TLB and physical address
17:25:37 Page table size can be reduced by increasing page size
17:30:07 Finding the optimal page size for minimal internal fragmentation and page table size.
17:32:17 Optimal page size affects page table size and internal fragmentation
17:37:10 Memory division into units and load time calculation
17:39:33 Calculating CPU Time Fraction for Loading Page Table
17:43:41 Dividing program into pages and calculating required pages for text, data, and stack sections
17:45:50 Calculating number of pages based on address space and page size
17:50:07 Introduction to Hashed Page Table
17:52:19 Collision resolution technique using chaining
17:56:31 VUM architecture involves tradeoff between space and time 
```

<hr>

# C++ì–¸ì–´ ê³µë¶€í•˜ê¸° ì¢‹ë‹¤.[|ğŸ”|](#link)
https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf

# `std::prt::read_volatile`[|ğŸ”|](#link)
https://doc.rust-lang.org/std/ptr/fn.read_volatile.html

```rs
pub unsafe fn read_volatile<T>(src: *const T) -> T
```

- https://doc.rust-lang.org/std/ptr/fn.read_volatile.html#examples
```rs
let x = 12;
let y = &x as *const i32;

unsafe {
    assert_eq!(std::ptr::read_volatile(y), 12);
}
```

- Performs a volatile read of the value from `src` without moving it. This leaves the memory in `src` unchanged.
  - srcì—ì„œ ê°’ì„ ì´ë™í•˜ì§€ ì•Šê³  íœ˜ë°œì„±ìœ¼ë¡œ ì½ìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë©´ ë©”ëª¨ë¦¬ê°€ srcë¡œ ë°”ë€Œì§€ ì•ŠìŠµë‹ˆë‹¤.


- Volatile operations are intended to act on I/O memory, and are guaranteed to not be elided or reordered by the compiler across other volatile operations.
  - íœ˜ë°œì„± ì—°ì‚°ì€ I/O ë©”ëª¨ë¦¬ì— ì‘ìš©í•˜ë„ë¡ ë˜ì–´ ìˆìœ¼ë©°, ì»´íŒŒì¼ëŸ¬ê°€ ë‹¤ë¥¸ íœ˜ë°œì„± ì—°ì‚°ì— ê±¸ì³ ì œê±°í•˜ê±°ë‚˜ ì¬ì •ë ¬í•˜ì§€ ì•Šë„ë¡ ë³´ì¥í•©ë‹ˆë‹¤.

# Notes

- Rust does not currently have a rigorously and formally defined memory model, so the precise semantics of what "volatile" means here is subject to change over time. That being said, the semantics will almost always end up pretty similar to `[C11's definition of volatile][c11]`.
  - ëŸ¬ìŠ¤íŠ¸ëŠ” í˜„ì¬ ì—„ê²©í•˜ê³  í˜•ì‹ì ìœ¼ë¡œ ì •ì˜ëœ ë©”ëª¨ë¦¬ ëª¨ë¸ì„ ê°€ì§€ê³  ìˆì§€ ì•Šìœ¼ë¯€ë¡œ ì—¬ê¸°ì„œ "íœ˜ë°œì„±"ì´ ë¬´ì—‡ì„ ì˜ë¯¸í•˜ëŠ”ì§€ì— ëŒ€í•œ ì •í™•í•œ ì˜ë¯¸ë¡ ì€ ì‹œê°„ì´ ì§€ë‚¨ì— ë”°ë¼ ë³€ê²½ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì¦‰, ì˜ë¯¸ë¡ ì€ ê±°ì˜ í•­ìƒ '[C11ì˜ íœ˜ë°œì„±][c11]ì˜ ì •ì˜ì™€ ìƒë‹¹íˆ ìœ ì‚¬í•˜ê²Œ ëë‚  ê²ƒì…ë‹ˆë‹¤.

- The compiler shouldn't change the relative order or number of volatile memory operations. However, volatile memory operations on zero-sized types (e.g., if a zero-sized type is passed to `read_volatile`) are noops and may be ignored.
  - ì»´íŒŒì¼ëŸ¬ëŠ” íœ˜ë°œì„± ë©”ëª¨ë¦¬ ì—°ì‚°ì˜ ìƒëŒ€ì ì¸ ìˆœì„œë‚˜ ê°œìˆ˜ë¥¼ ë³€ê²½í•´ì„œëŠ” ì•ˆ ë©ë‹ˆë‹¤. í•˜ì§€ë§Œ ì œë¡œ ì‚¬ì´ì¦ˆ íƒ€ì…ì—ì„œì˜ íœ˜ë°œì„± ë©”ëª¨ë¦¬ ì—°ì‚°(ì˜ˆë¥¼ ë“¤ì–´, ì œë¡œ ì‚¬ì´ì¦ˆ íƒ€ì…ì´ 'read_volatile'ë¡œ ì „ë‹¬ë˜ëŠ” ê²½ìš°)ì€ noopsì´ë©° ë¬´ì‹œë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

 [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf

# Safety[|ğŸ”|](#link)

- Behavior is undefined if any of the following conditions are violated:
  - ë‹¤ìŒ ì¡°ê±´ ì¤‘ í•˜ë‚˜ë¼ë„ ìœ„ë°˜í•˜ë©´ ë™ì‘ì´ ì •ì˜ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤:

  - * `src` must be [valid] for reads.
    - * ì½ê¸°ì˜ ê²½ìš° 'src'ê°€ [valid]ì—¬ì•¼ í•©ë‹ˆë‹¤.

  - * `src` must be properly aligned.
    - * 'src'ê°€ ì˜¬ë°”ë¥´ê²Œ ì •ë ¬ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.

  - * `src` must point to a properly initialized value of type `T`.
    - * 'src'ëŠ” Tí˜•ì˜ ì´ˆê¸°í™”ëœ ê°’ì„ ê°€ë¦¬ì¼œì•¼ í•©ë‹ˆë‹¤.

- Like [`read`], `read_volatile` creates a bitwise copy of `T`, regardless of whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the returned value and the value at `*src` can [violate memory safety][read-ownership]. However, storing non-[`Copy`] types in volatile memory is almost certainly incorrect.
  - read_volatileì€ readì™€ ë§ˆì°¬ê°€ì§€ë¡œ Tê°€ [Copy]ì´ë“  ìƒê´€ì—†ì´ Tì˜ ë¹„íŠ¸ ë‹¨ìœ„ ë³µì‚¬ë³¸ì„ ë§Œë“­ë‹ˆë‹¤. ë§Œì•½ Tê°€ [Copy]ê°€ ì•„ë‹ˆë¼ë©´ ë°˜í™˜ëœ ê°’ê³¼ *src ê°’ì„ ëª¨ë‘ ì‚¬ìš©í•˜ë©´ ë©”ëª¨ë¦¬ ì•ˆì „ì„±[read-ì†Œìœ ê¶Œ]ì„ ì¹¨í•´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ [Copy]ê°€ ì•„ë‹Œ ìœ í˜•ì„ íœ˜ë°œì„± ë©”ëª¨ë¦¬ì— ì €ì¥í•˜ëŠ” ê²ƒì€ ê±°ì˜ í™•ì‹¤í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

- Note that even if `T` has size `0`, the pointer must be non-null and properly aligned.
  - 'T'ì˜ í¬ê¸°ê°€ '0'ì´ë”ë¼ë„ í¬ì¸í„°ê°€ nullì´ ì•„ë‹ˆë©° ì ì ˆí•˜ê²Œ ì •ë ¬ë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.

 [valid]: self#safety
 [read-ownership]: read#ownership-of-the-returned-value

- Just like in C, whether an operation is volatile has no bearing whatsoever on questions involving concurrent access from multiple threads. Volatile accesses behave exactly like non-atomic accesses in that regard. In particular, a race between a `read_volatile` and any write operation to the same location is undefined behavior.
  - Cì™€ ë§ˆì°¬ê°€ì§€ë¡œ ì—°ì‚°ì˜ íœ˜ë°œì„± ì—¬ë¶€ëŠ” ì—¬ëŸ¬ ìŠ¤ë ˆë“œì—ì„œ ë™ì‹œì— ì•¡ì„¸ìŠ¤í•˜ëŠ” ê²ƒê³¼ ê´€ë ¨ëœ ì§ˆë¬¸ê³¼ ì „í˜€ ê´€ë ¨ì´ ì—†ìŠµë‹ˆë‹¤. íœ˜ë°œì„± ì•¡ì„¸ìŠ¤ëŠ” ì›ìê°€ ì•„ë‹Œ ì•¡ì„¸ìŠ¤ì™€ ë˜‘ê°™ì´ ì‘ë™í•©ë‹ˆë‹¤. íŠ¹íˆ 'read_volatile'ê³¼ ë™ì¼í•œ ìœ„ì¹˜ì— ëŒ€í•œ ì„ì˜ì˜ ì“°ê¸° ì—°ì‚° ê°„ì˜ ê²½ìŸì€ ì •ì˜ë˜ì§€ ì•Šì€ ë™ì‘ì…ë‹ˆë‹¤.

<hr />

<hr />

<hr />

# ìš©ì–´ì •ë¦¬[|ğŸ”|](#link)

# DPLê°œë…ì´í•´[|ğŸ”|](#link)
- Privilege Level (Ring 0, Ring 3)
ì¶œì²˜: https://elfmfl.tistory.com/2 [Elfmfl:í‹°ìŠ¤í† ë¦¬]
# DPL
- (Descriptor Privilege Level)
  -  C++ë¡œ ë‚˜ë§Œì˜ ìš´ì˜ì²´ì¬ë§Œë“¤ê¸°(p.113)

# Programs Callì´í•´[|ğŸ”|](#link)
- https://youtu.be/e5g8eYKEhMw?si=vcOuJlO55xvguRwp

# ì‹œìŠ¤í…œ ì½œ ì£¼ìš” ê°œë…[|ğŸ”|](#link)
- https://youtu.be/bfZ-f0m4nqQ?si=2vhhSy9DH6yc_KYd

# Effective Addressë€? ì„ í˜•ì£¼ì†Œ[|ğŸ”|](#link)
- http://www.iamroot.org/xe/index.php?mid=Kernel&document_srl=26233

# [ì»´í“¨í„° êµ¬ì¡°] Instruction Sets[|ğŸ”|](#link)
- https://blackinkgj.github.io/ISA/
  - ì¶œì²˜ : Willian Stallings. (2013). Computer Organization and Architecture. London:Pearson

# [Assembly] Can anyone explain to me what an effective address is?[|ğŸ”|](#link)

I am taking a course on data organization this semester, and since it is the professor's first year teaching, he is not the greatest at explaining concepts. I have an assignment where I read some assembly code and identify what is going on and what the effective address is. I just have no idea how to identify what the EA is. Reading the textbook and going on Wikipedia have not helped either. Does anyone have a simple, concise explanation as to what it is? I can provide the code I am looking at for the assignment if need be.
-  [ì–´ì…ˆë¸”ë¦¬] íš¨ê³¼ì ì¸ ì£¼ì†Œê°€ ë¬´ì—‡ì¸ì§€ ì„¤ëª…í•´ ì¤„ ìˆ˜ ìˆëŠ” ì‚¬ëŒì´ ìˆìŠµë‹ˆê¹Œ?
  - ì €ëŠ” ì´ë²ˆ í•™ê¸°ì— ë°ì´í„° ì •ë¦¬ì— ëŒ€í•œ ê°•ì˜ë¥¼ ë“£ê³  ìˆëŠ”ë° êµìˆ˜ë‹˜ì˜ 1í•™ë…„ ê°•ì˜ì´ê¸° ë•Œë¬¸ì— ê°œë… ì„¤ëª…ì— ëŠ¥ìˆ™í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì €ëŠ” ì–´ì…ˆë¸”ë¦¬ ì½”ë“œë¥¼ ì½ê³  ë¬´ìŠ¨ ì¼ì´ ì¼ì–´ë‚˜ê³  ìˆëŠ”ì§€, ìœ íš¨ ì£¼ì†Œê°€ ë¬´ì—‡ì¸ì§€ ì‹ë³„í•˜ëŠ” ê³¼ì œê°€ ìˆìŠµë‹ˆë‹¤. EAê°€ ë¬´ì—‡ì¸ì§€ ì‹ë³„í•˜ëŠ” ë°©ë²•ì„ ì „í˜€ ëª¨ë¥´ê² ìŠµë‹ˆë‹¤. êµê³¼ì„œë¥¼ ì½ê³  ìœ„í‚¤í”¼ë””ì•„ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒë„ ë„ì›€ì´ ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ê·¸ê²ƒì´ ë¬´ì—‡ì¸ì§€ì— ëŒ€í•œ ê°„ë‹¨í•˜ê³  ê°„ê²°í•œ ì„¤ëª…ì„ ê°€ì§€ê³  ìˆëŠ” ì‚¬ëŒì´ ìˆìŠµë‹ˆê¹Œ? í•„ìš”í•˜ë‹¤ë©´ ì œê°€ ì°¾ê³  ìˆëŠ” ì½”ë“œë¥¼ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- https://www.reddit.com/r/learnprogramming/s/3Zcy1WFVoV

# Addressing mode[|ğŸ”|](#link)
- https://en.m.wikipedia.org/wiki/Addressing_mode

# x86 memory segmentation[|ğŸ”|](#link)
- https://en.m.wikipedia.org/wiki/X86_memory_segmentation

# Real mode[|ğŸ”|](#link)
- https://en.m.wikipedia.org/wiki/Real_mode

# Protected mode[|ğŸ”|](#link)
- https://en.m.wikipedia.org/wiki/Protected_mode



<hr />  

# ì´ ì‚¬ëŒì€ ë„˜ ì¢‹ë‹¤.
# (251003)Project: Coding a GRUB bootloader for booting Linux | dr Jonas Birch[|ğŸ”|](#link)
- https://youtu.be/ukIajayMv5U?si=w1tlw42I4nHsp4G7


<hr />

<hr />
